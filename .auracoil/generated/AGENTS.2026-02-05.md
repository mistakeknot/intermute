# AGENTS.md

> Auto-generated by [Auracoil](https://github.com/anthropics/auracoil) using GPT 5.2 Pro analysis.
> Last updated: 2026-02-05

This documentation helps AI coding assistants (Claude Code, Codex CLI) work effectively with this codebase.

---

## Overview

Intermute is a Go service that coordinates "agents" via a REST API (source of truth) plus WebSockets for real-time delivery, persisting state in SQLite. It ships as a Cobra CLI with `serve` (run server) and `init` (generate API keys) commands. (`README.md`, `cmd/intermute/main.go`, `go.mod`)

## Quick Start

### Requirements

* Go toolchain: `go1.24.12` (pinned by `toolchain` in `go.mod`)

### Run the server

```bash
# Start HTTP + WebSocket server (default: 127.0.0.1:7338, DB: intermute.db)
go run ./cmd/intermute serve
```

Flags (from `cmd/intermute/main.go`):

```bash
go run ./cmd/intermute serve --host 127.0.0.1 --port 7338 --db intermute.db
```

### Initialize auth keys (for non-localhost callers)

```bash
# Writes/updates a keys file and prints a generated API key
go run ./cmd/intermute init --project autarch
```

Optional (from `cmd/intermute/main.go`):

```bash
go run ./cmd/intermute init --project autarch --keys-file ./intermute.keys.yaml
```

### Auth environment (clients)

From `README.md` and `cmd/intermute/main.go` output:

```bash
export INTERMUTE_URL=http://localhost:7338
export INTERMUTE_API_KEY=<printed-key>      # required for non-localhost
export INTERMUTE_PROJECT=autarch            # required when INTERMUTE_API_KEY is set
export INTERMUTE_AGENT_NAME=agent-a         # optional override
```

### WebSocket (local dev)

```text
ws://localhost:7338/ws/agents/<agent_id>?project=<project>
```

(`README.md`)

### Tests

```bash
go test ./...
```

(`README.md`)

## Architecture

### High-level wiring

All composition happens in `cmd/intermute/main.go`:

* **Storage**: SQLite store created via `internal/storage/sqlite` (`sqlite.New(dbPath)`)
* **Auth**: key bootstrapping + keyring load + middleware from `internal/auth`

  * `auth.ResolveKeysPath()`
  * `auth.BootstrapDevKey(...)`
  * `auth.LoadKeyringFromEnv()`
  * `auth.Middleware(keyring)`
* **Realtime**: WebSocket hub from `internal/ws` (`ws.NewHub()`)
* **HTTP API**: domain service/router from `internal/http`

  * `httpapi.NewDomainService(store).WithBroadcaster(hub)`
  * `httpapi.NewDomainRouter(svc, hub.Handler(), auth.Middleware(keyring))`
* **Server wrapper**: `internal/server` (`server.New(...)`, `srv.Start()`, `srv.Shutdown(...)`)

### Request/data flow

From the `serve` command wiring in `cmd/intermute/main.go`:

1. **HTTP request** → auth middleware (`internal/auth`) → router (`internal/http`)
2. Router calls service (`internal/http`) → store (`internal/storage/sqlite`)
3. Service broadcasts events to WebSocket hub (`internal/ws`) when configured via `.WithBroadcaster(hub)`
4. Hub serves WebSocket connections via `hub.Handler()` mounted into the router (`cmd/intermute/main.go`)

### Directory map (entrypoints and responsibilities)

(Referenced/imported by `cmd/intermute/main.go`)

```text
cmd/intermute/main.go            # Cobra CLI entrypoint; wires everything

internal/auth/                   # Keyring resolution/loading, auth middleware, dev-key bootstrap
internal/cli/                    # CLI helpers used by `intermute init` (e.g., keyfile generation)
internal/http/                   # Domain HTTP router + service (REST + WS mounting)
internal/server/                 # HTTP server wrapper (start/shutdown)
internal/storage/sqlite/         # SQLite-backed persistence
internal/ws/                     # WebSocket hub + handler
```

## Code Conventions

### Imports & package naming

* Standard library first, then third-party, then internal packages; use aliases to avoid name conflicts.

  * Example alias: `httpapi "github.com/mistakeknot/intermute/internal/http"` (`cmd/intermute/main.go`)
* Keep server-only code in `internal/...`; CLI entrypoint lives under `cmd/intermute/...` (`cmd/intermute/main.go`)

### Error handling

* Wrap errors with context using `%w` for stackable causes:

  * `return fmt.Errorf("store init: %w", err)` (`cmd/intermute/main.go`)

### Configuration conventions

* Server config via Cobra flags on `serve`: `--host`, `--port`, `--db` (`cmd/intermute/main.go`)
* Auth/key config uses a "keys file" resolved by `auth.ResolveKeysPath()` and/or environment (`README.md`, `cmd/intermute/main.go`)
* When printing instructions to users, prefer explicit `export ...` commands (see `init` output in `cmd/intermute/main.go`)

## Gotchas

1. **Running without a subcommand won't start the server**
   The server is started by `intermute serve` (root command only registers subcommands). (`cmd/intermute/main.go`)
   Note: `README.md` shows `go run ./cmd/intermute`; prefer `go run ./cmd/intermute serve`.

2. **Localhost auth bypass vs non-localhost enforcement**
   Localhost requests are allowed without auth by default; non-localhost requires `Authorization: Bearer <key>`. (`README.md`, `cmd/intermute/main.go`)

3. **`project` becomes mandatory when using a bearer key**
   With API key auth, `project` is required on:

   * `POST /api/agents`
   * `POST /api/messages`
     (`README.md`)

4. **Dev key bootstrap can surprise you**
   On startup, if the keys file is missing, the server attempts to bootstrap a dev key and logs it (including file path). (`cmd/intermute/main.go`, `README.md`)

5. **Pinned Go toolchain**
   CI/agents using older Go may fail due to `go 1.24` and `toolchain go1.24.12`. (`go.mod`)

6. **Shutdown timeout is 5 seconds**
   Long-running requests may be cut off on SIGINT/SIGTERM due to `context.WithTimeout(..., 5*time.Second)`. (`cmd/intermute/main.go`)

## Common Patterns

### Cobra CLI structure

```go
// cmd/intermute/main.go
root := &cobra.Command{
	Use:   "intermute",
	Short: "Intermute - Agent coordination and domain API server",
}

root.AddCommand(serveCmd())
root.AddCommand(initCmd())

if err := root.Execute(); err != nil {
	os.Exit(1)
}
```

### Server wiring (store + auth + WS + router)

```go
// cmd/intermute/main.go (serveCmd RunE)
store, err := sqlite.New(dbPath)
if err != nil {
	return fmt.Errorf("store init: %w", err)
}

keysPath := auth.ResolveKeysPath()
_, _ = auth.BootstrapDevKey(keysPath, "dev") // logs warning/creation info

keyring, err := auth.LoadKeyringFromEnv()
if err != nil {
	return fmt.Errorf("auth init: %w", err)
}

hub := ws.NewHub()
svc := httpapi.NewDomainService(store).WithBroadcaster(hub)

router := httpapi.NewDomainRouter(
	svc,
	hub.Handler(),
	auth.Middleware(keyring),
)
```

### Error wrapping pattern

```go
// cmd/intermute/main.go
if err != nil {
	return fmt.Errorf("server init: %w", err)
}
```

### Graceful shutdown (signals + context timeout)

```go
// cmd/intermute/main.go
quit := make(chan os.Signal, 1)
signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

go func() {
	<-quit
	log.Println("shutting down...")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	_ = srv.Shutdown(ctx)
}()
```

### `init` command output contract (what scripts can rely on)

```go
// cmd/intermute/main.go (initCmd RunE) prints:
fmt.Printf("Created API key for project %q in %s\n\n", project, keysFile)
fmt.Printf("Key: %s\n\n", key)
fmt.Printf("  export INTERMUTE_API_KEY=%s\n", key)
fmt.Printf("  -H \"Authorization: Bearer %s\"\n", key)
fmt.Printf("  INTERMUTE_KEYS_FILE=%s intermute serve\n", keysFile)
```

---

## Contributing to This Doc

This file is generated by Auracoil. To update:
1. Run `auracoil update` to refresh from codebase changes
2. For custom sections, add them between `<!-- custom:start -->` and `<!-- custom:end -->` markers

<!-- custom:start -->
<!-- Add your custom content here - it will be preserved during updates -->
<!-- custom:end -->
